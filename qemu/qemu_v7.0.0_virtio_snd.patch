diff --git a/hw/audio/Kconfig b/hw/audio/Kconfig
index e76c69ca7e..326869d0f7 100644
--- a/hw/audio/Kconfig
+++ b/hw/audio/Kconfig
@@ -47,3 +47,8 @@ config PL041
 
 config CS4231
     bool
+
+config VIRTIO_SND
+    bool
+    default y if PCI_DEVICES
+    depends on PCI
diff --git a/hw/audio/meson.build b/hw/audio/meson.build
index e48a9fc73d..455e6a1501 100644
--- a/hw/audio/meson.build
+++ b/hw/audio/meson.build
@@ -12,3 +12,4 @@ softmmu_ss.add(when: 'CONFIG_PL041', if_true: files('pl041.c', 'lm4549.c'))
 softmmu_ss.add(when: 'CONFIG_SB16', if_true: files('sb16.c'))
 softmmu_ss.add(when: 'CONFIG_VT82C686', if_true: files('via-ac97.c'))
 softmmu_ss.add(when: 'CONFIG_WM8750', if_true: files('wm8750.c'))
+softmmu_ss.add(when: 'CONFIG_VIRTIO_SND', if_true: files('virtio-snd.c'))
diff --git a/hw/audio/virtio-snd.c b/hw/audio/virtio-snd.c
new file mode 100644
index 0000000000..6173f0faa1
--- /dev/null
+++ b/hw/audio/virtio-snd.c
@@ -0,0 +1,1125 @@
+/*
+ * Virtio Sound device
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/atomic.h"
+#include "qemu/iov.h"
+#include "qemu/main-loop.h"
+#include "qemu/module.h"
+#include "hw/virtio/virtio.h"
+#include "audio/audio.h"
+#include "qemu/error-report.h"
+#include "qemu/timer.h"
+#include "qemu/option.h"
+#include "qemu/option_int.h"
+#include "qemu/config-file.h"
+#include "qapi/qmp/qdict.h"
+#include "hw/virtio/virtio-snd.h"
+#include "hw/virtio/virtio-bus.h"
+#include "qapi/error.h"
+#include "qapi/qapi-events-audio.h"
+#include "hw/qdev-properties.h"
+#include "qapi/qapi-types-migration.h"
+#include "qapi/qapi-events-migration.h"
+#include "migration/misc.h"
+#include "standard-headers/linux/ethtool.h"
+#include "sysemu/sysemu.h"
+#include "trace.h"
+#include "monitor/qdev.h"
+#include "hw/pci/pci.h"
+#include "intel-hda-defs.h"
+
+#define VIRTIO_SOUND_VM_VERSION 1
+
+#define VIRTIO_SOUND_JACK_DEFAULT 1
+#define VIRTIO_SOUND_STREAM_DEFAULT 1
+
+#define VIRTIO_SOUND_HDA_FN_NID_OUT 0
+#define VIRTIO_SOUND_HDA_FN_NID_IN 1
+
+#define virtio_snd_log(...) AUD_log("virtio sound info", __VA_ARGS__)
+#define virtio_snd_warn(...) AUD_log("virtio sound warn", __VA_ARGS__)
+#define virtio_snd_err(...) AUD_log("virtio sound err", __VA_ARGS__)
+
+static void virtio_snd_get_config(VirtIODevice *vdev, uint8_t *config)
+{
+    VirtIOSound *s = VIRTIO_SOUND(vdev);
+    virtio_snd_config sndcfg;
+
+    memset(&sndcfg, 0, sizeof(virtio_snd_config));
+    stl_le_p(&(sndcfg.jacks), s->snd_conf.jacks);
+    stl_le_p(&(sndcfg.streams), s->snd_conf.streams);
+    stl_le_p(&(sndcfg.chmaps), s->snd_conf.chmaps);
+
+    memcpy(config, &sndcfg, sizeof(virtio_snd_config));
+}
+
+static void virtio_snd_set_config(VirtIODevice *vdev, const uint8_t *config)
+{
+    VirtIOSound *s = VIRTIO_SOUND(vdev);
+    virtio_snd_config sndcfg;
+
+    memcpy(&sndcfg, config, sizeof(virtio_snd_config));
+
+    memcpy(&s->snd_conf.jacks, &sndcfg.jacks, sizeof(uint32_t));
+    memcpy(&s->snd_conf.streams, &sndcfg.streams, sizeof(uint32_t));
+    memcpy(&s->snd_conf.chmaps, &sndcfg.streams, sizeof(uint32_t));
+}
+
+static const VMStateDescription vmstate_virtio_snd_device = {
+    .name = "virtio-snd-device",
+    .version_id = VIRTIO_SOUND_VM_VERSION,
+    .minimum_version_id = VIRTIO_SOUND_VM_VERSION,
+};
+
+static const VMStateDescription vmstate_virtio_snd = {
+    .name = "virtio-sound",
+    .minimum_version_id = VIRTIO_SOUND_VM_VERSION,
+    .version_id = VIRTIO_SOUND_VM_VERSION,
+    .fields = (VMStateField[]) {
+        VMSTATE_VIRTIO_DEVICE,
+        VMSTATE_END_OF_LIST()
+    },
+};
+
+static Property virtio_snd_properties[] = {
+    DEFINE_AUDIO_PROPERTIES(VirtIOSound, card),
+    DEFINE_PROP_UINT32("jacks", VirtIOSound, snd_conf.jacks, VIRTIO_SOUND_JACK_DEFAULT),
+    DEFINE_PROP_UINT32("streams", VirtIOSound, snd_conf.streams, VIRTIO_SOUND_STREAM_DEFAULT),
+    DEFINE_PROP_UINT32("chmaps", VirtIOSound, snd_conf.chmaps , VIRTIO_SOUND_STREAM_DEFAULT),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static uint64_t virtio_snd_get_features(VirtIODevice *vdev, uint64_t features,
+                                        Error **errp)
+{
+    return vdev->host_features;
+}
+/*
+ * Get a specific jack from the VirtIOSound card.
+ *
+ * @s: VirtIOSound card device.
+ * @id: Jack id
+ */
+static virtio_snd_jack *virtio_snd_get_jack(VirtIOSound *s, uint32_t id) {
+    if (id >= s->snd_conf.jacks) {
+        return NULL;
+    }
+    return s->jacks[id];
+}
+
+/*
+ * Handles VIRTIO_SND_R_JACK_INFO.
+ * The function writes the info structs and response to the virtqueue element.
+ * Returns the used size in bytes.
+ *
+ * @s: VirtIOSound card
+ * @elem: The request element from control queue
+ */
+static uint32_t virtio_snd_handle_jack_info(VirtIOSound *s, VirtQueueElement *elem)
+{
+    virtio_snd_query_info req;
+    size_t sz = iov_to_buf(elem->out_sg, elem->out_num, 0, &req, sizeof(req));
+    assert(sz == sizeof(virtio_snd_query_info));
+
+    virtio_snd_hdr resp;
+
+    virtio_snd_jack_info *jack_info = (virtio_snd_jack_info *)g_malloc0(sizeof(virtio_snd_jack_info) * req.count);
+
+    if (iov_size(elem->in_sg, elem->in_num) <
+        sizeof(virtio_snd_hdr) + req.count * req.size ) {
+        virtio_snd_err("Response buffer size too small for jack info. Got: %lu Need: %lu\n",
+                       iov_size(elem->in_sg, elem->in_num),
+                       sizeof(virtio_snd_hdr) + req.count * req.size);
+        resp.code = VIRTIO_SND_S_BAD_MSG;
+        goto done;
+    }
+
+    for (int i = req.start_id; i < req.count + req.start_id; i++) {
+        virtio_snd_jack *jack = virtio_snd_get_jack(s, i);
+        if (!jack) {
+            virtio_snd_err("Invalid jack id: %d\n", i);
+            resp.code = VIRTIO_SND_S_BAD_MSG;
+            goto done;
+        }
+
+        jack_info[i - req.start_id].hdr.hda_fn_nid = jack->hda_fn_nid;
+        jack_info[i - req.start_id].features = jack->features;
+        jack_info[i - req.start_id].hda_reg_defconf = jack->hda_reg_defconf;
+        jack_info[i - req.start_id].hda_reg_caps = jack->hda_reg_caps;
+        jack_info[i - req.start_id].connected = jack->connected;
+        memset(jack_info[i - req.start_id].padding, 0, sizeof(jack_info[i - req.start_id].padding));
+    }
+
+    resp.code = VIRTIO_SND_S_OK;
+done:
+    sz = iov_from_buf(elem->in_sg, elem->in_num, 0, &resp, sizeof(resp));
+    assert(sz == sizeof(virtio_snd_hdr));
+
+    if (resp.code == VIRTIO_SND_S_BAD_MSG) {
+        if (jack_info)
+            g_free(jack_info);
+        return sz;
+    }
+
+    sz = iov_from_buf(elem->in_sg, elem->in_num, sizeof(virtio_snd_hdr), jack_info,
+                      sizeof(virtio_snd_jack_info) * req.count);
+    assert(sz == req.count * req.size);
+    g_free(jack_info);
+    return sizeof(virtio_snd_hdr) + sz;
+}
+
+/*
+ * Handles VIRTIO_SND_R_JACK_REMAP.
+ * Not implemented yet.
+ *
+ * @s: VirtIOSound card
+ * @elem: The request element from control queue
+ */
+static uint32_t virtio_snd_handle_jack_remap(VirtIOSound *s, VirtQueueElement *elem)
+{
+    virtio_snd_hdr resp;
+    resp.code = VIRTIO_SND_S_OK;
+
+    // TODO: implement remap
+
+    size_t sz;
+    sz = iov_from_buf(elem->in_sg, elem->in_num, 0, &resp, sizeof(resp));
+    assert(sz == sizeof(virtio_snd_hdr));
+    return sz;
+}
+
+/*
+ * Get a specific stream from the virtio sound card device.
+ *
+ * @s: VirtIOSound card device
+ * @stream: Stream id
+ *
+ * Returns NULL if function fails.
+ * TODO: Make failure more explicit. Could return NULL if stream wasn't allocated
+ */
+static virtio_snd_pcm_stream *virtio_snd_pcm_get_stream(VirtIOSound *s,
+                                                        uint32_t stream)
+{
+    if (stream >= s->snd_conf.streams) {
+        virtio_snd_err("Invalid stream request %d\n", stream);
+        return NULL;
+    }
+    return s->streams[stream];
+}
+
+/*
+ * Handle the VIRTIO_SND_R_PCM_INFO request.
+ * The function writes the info structs to the request element.
+ * Returns the used size in bytes.
+ *
+ * @s: VirtIOSound card device
+ * @elem: The request element from control queue
+ */
+static uint32_t virtio_snd_handle_pcm_info(VirtIOSound *s, VirtQueueElement *elem)
+{
+    virtio_snd_query_info req;
+    uint32_t sz;
+    sz = iov_to_buf(elem->out_sg, elem->out_num, 0, &req, sizeof(req));
+    assert(sz == sizeof(virtio_snd_query_info));
+
+    virtio_snd_pcm_info *pcm_info = (virtio_snd_pcm_info *)
+                                    g_malloc0(sizeof(virtio_snd_pcm_info)
+                                              * req.count);
+
+    virtio_snd_hdr resp;
+    if (iov_size(elem->in_sg, elem->in_num) <
+        sizeof(virtio_snd_hdr) + req.size * req.count) {
+        virtio_snd_err("Insufficient space for pcm info req. Got: %lu, Required: %lu\n",
+                iov_size(elem->in_sg, elem->in_num), sizeof(virtio_snd_pcm_info));
+        resp.code = VIRTIO_SND_S_BAD_MSG;
+        goto done;
+    }
+
+    virtio_snd_pcm_stream *stream;
+    for (int i = req.start_id; i < req.start_id + req.count; i++) {
+        stream = virtio_snd_pcm_get_stream(s, i);
+
+        if (!stream) {
+            virtio_snd_err("Invalid stream id: %d\n", i);
+            resp.code = VIRTIO_SND_S_BAD_MSG;
+            goto done;
+        }
+
+        pcm_info[i - req.start_id].hdr.hda_fn_nid = stream->hda_fn_nid;
+        pcm_info[i - req.start_id].features = stream->features;
+        pcm_info[i - req.start_id].formats = stream->formats;
+        pcm_info[i - req.start_id].rates = stream->rates;
+        pcm_info[i - req.start_id].direction = stream->direction;
+        pcm_info[i - req.start_id].channels_min = stream->channels_min;
+        pcm_info[i - req.start_id].channels_max = stream->channels_max;
+
+        memset(&pcm_info[i].padding, 0, sizeof(pcm_info[i].padding));
+    }
+
+    resp.code = VIRTIO_SND_S_OK;
+done:
+    sz = iov_from_buf(elem->in_sg, elem->in_num, 0, &resp, sizeof(resp));
+    assert(sz == sizeof(virtio_snd_hdr));
+
+    if (resp.code == VIRTIO_SND_S_BAD_MSG) {
+        if (pcm_info)
+            g_free(pcm_info);
+        return sz;
+    }
+
+    sz = iov_from_buf(elem->in_sg, elem->in_num, sizeof(virtio_snd_hdr), pcm_info,
+            sizeof(virtio_snd_pcm_info) * req.count);
+    assert(sz == req.size * req.count);
+    g_free(pcm_info);
+    return sizeof(virtio_snd_hdr) + sz;
+}
+
+/*
+ * Set the given stream params.
+ * Called by both virtio_snd_handle_pcm_set_params and during device
+ * initialization.
+ * Returns a virtio sound status VIRTIO_SND_S_*
+ *
+ * @s: VirtIOSound card device
+ * @params: The PCM params as defined in the virtio specification
+ */
+static uint32_t virtio_snd_pcm_set_params_impl(VirtIOSound *s,
+                                               virtio_snd_pcm_set_params *params)
+{
+    uint32_t st = params->hdr.stream_id;
+    if (st > s->snd_conf.streams || !(s->pcm_params)) {
+        virtio_error(VIRTIO_DEVICE(s), "Streams not initalized\n");
+        return VIRTIO_SND_S_BAD_MSG;
+    }
+
+    if (!s->pcm_params[st]) {
+        s->pcm_params[st] = (virtio_snd_pcm_params *)
+                            g_malloc0(sizeof(virtio_snd_pcm_params));
+    }
+    virtio_snd_pcm_params *st_params = s->pcm_params[st];
+
+    st_params->features = params->features;
+    st_params->buffer_bytes = params->buffer_bytes;
+    st_params->period_bytes = params->period_bytes;
+
+    if (params->channel < 1 || params->channel > AUDIO_MAX_CHANNELS) {
+        virtio_snd_err("Number of channels not supported\n");
+        return VIRTIO_SND_S_NOT_SUPP;
+    }
+    st_params->channel = params->channel;
+
+    uint32_t supported_formats = 1 << VIRTIO_SND_PCM_FMT_S8 |
+                                 1 << VIRTIO_SND_PCM_FMT_U8 |
+                                 1 << VIRTIO_SND_PCM_FMT_S16 |
+                                 1 << VIRTIO_SND_PCM_FMT_U16 |
+                                 1 << VIRTIO_SND_PCM_FMT_S32 |
+                                 1 << VIRTIO_SND_PCM_FMT_U32 |
+                                 1 << VIRTIO_SND_PCM_FMT_FLOAT;
+
+    uint32_t supported_rates = 1 << VIRTIO_SND_PCM_RATE_5512 |
+                               1 << VIRTIO_SND_PCM_RATE_8000 |
+                               1 << VIRTIO_SND_PCM_RATE_11025 |
+                               1 << VIRTIO_SND_PCM_RATE_16000 |
+                               1 << VIRTIO_SND_PCM_RATE_22050 |
+                               1 << VIRTIO_SND_PCM_RATE_32000 |
+                               1 << VIRTIO_SND_PCM_RATE_44100 |
+                               1 << VIRTIO_SND_PCM_RATE_48000 |
+                               1 << VIRTIO_SND_PCM_RATE_64000 |
+                               1 << VIRTIO_SND_PCM_RATE_88200 |
+                               1 << VIRTIO_SND_PCM_RATE_96000 |
+                               1 << VIRTIO_SND_PCM_RATE_176399 |
+                               1 << VIRTIO_SND_PCM_RATE_192000 |
+                               1 << VIRTIO_SND_PCM_RATE_384000;
+
+    if (!(supported_formats & (1 << params->format))) {
+        virtio_snd_err("Stream format not supported\n");
+        return VIRTIO_SND_S_NOT_SUPP;
+    }
+    st_params->format = params->format;
+
+    if (!(supported_rates & (1 << params->rate))) {
+        virtio_snd_err("Stream rate not supported\n");
+        return VIRTIO_SND_S_NOT_SUPP;
+    }
+    st_params->rate = params->rate;
+
+    st_params->period_bytes = params->period_bytes;
+    st_params->buffer_bytes = params->buffer_bytes;
+    return VIRTIO_SND_S_OK;
+}
+
+/*
+ * Handles the VIRTIO_SND_R_PCM_SET_PARAMS request.
+ * The function writes the response to the virtqueue element.
+ * Returns the used size in bytes.
+ *
+ * @s: VirtIOSound card device
+ * @elem: The request element from control queue
+ */
+static uint32_t virtio_snd_handle_pcm_set_params(VirtIOSound *s,
+                                             VirtQueueElement *elem)
+{
+    virtio_snd_pcm_set_params req;
+    uint32_t sz;
+    sz = iov_to_buf(elem->out_sg, elem->out_num, 0, &req, sizeof(req));
+    assert(sz == sizeof(virtio_snd_pcm_set_params));
+
+    virtio_snd_hdr resp;
+    resp.code = virtio_snd_pcm_set_params_impl(s, &req);
+
+    sz = iov_from_buf(elem->in_sg, elem->in_num, 0, &resp, sizeof(resp));
+    assert(sz == sizeof(virtio_snd_hdr));
+    return sz;
+}
+
+/*
+ * Get a QEMU Audiosystem compatible format value from a VIRTIO_SND_PCM_FMT_*
+ */
+static AudioFormat virtio_snd_get_qemu_format(uint32_t format)
+{
+    switch(format) {
+        case VIRTIO_SND_PCM_FMT_U8:
+            return AUDIO_FORMAT_U8;
+        case VIRTIO_SND_PCM_FMT_S8:
+            return AUDIO_FORMAT_S8;
+        case VIRTIO_SND_PCM_FMT_U16:
+            return AUDIO_FORMAT_U16;
+        case VIRTIO_SND_PCM_FMT_S16:
+            return AUDIO_FORMAT_S16;
+        case VIRTIO_SND_PCM_FMT_U32:
+            return AUDIO_FORMAT_U32;
+        case VIRTIO_SND_PCM_FMT_S32:
+            return AUDIO_FORMAT_S32;
+        case VIRTIO_SND_PCM_FMT_FLOAT:
+            return AUDIO_FORMAT_F32;
+        default:
+            return -1;
+    }
+}
+
+/*
+ * Get a QEMU Audiosystem compatible frequency value from a VIRTIO_SND_PCM_RATE_*
+ */
+static uint32_t virtio_snd_get_qemu_freq(uint32_t rate)
+{
+    switch(rate) {
+        case VIRTIO_SND_PCM_RATE_5512:
+            return 5512;
+        case VIRTIO_SND_PCM_RATE_8000:
+            return 8000;
+        case VIRTIO_SND_PCM_RATE_11025:
+            return 11025;
+        case VIRTIO_SND_PCM_RATE_16000:
+            return 16000;
+        case VIRTIO_SND_PCM_RATE_22050:
+            return 22050;
+        case VIRTIO_SND_PCM_RATE_32000:
+            return 32000;
+        case VIRTIO_SND_PCM_RATE_44100:
+            return 44100;
+        case VIRTIO_SND_PCM_RATE_48000:
+            return 48000;
+        case VIRTIO_SND_PCM_RATE_64000:
+            return 64000;
+        case VIRTIO_SND_PCM_RATE_88200:
+            return 88200;
+        case VIRTIO_SND_PCM_RATE_96000:
+            return 96000;
+        case VIRTIO_SND_PCM_RATE_176399:
+            return 176399;
+        case VIRTIO_SND_PCM_RATE_192000:
+            return 192000;
+        case VIRTIO_SND_PCM_RATE_384000:
+            return 384000;
+        default:
+            return -1;
+    }
+}
+
+/*
+ * Get QEMU Audiosystem compatible audsettings from virtio based pcm stream
+ * params.
+ */
+static void virtio_snd_get_qemu_audsettings(audsettings *as,
+                                            virtio_snd_pcm_params *params)
+{
+    as->nchannels = params->channel;
+    as->fmt = virtio_snd_get_qemu_format(params->format);
+    as->freq = virtio_snd_get_qemu_freq(params->rate);
+    as->endianness = AUDIO_HOST_ENDIANNESS;
+}
+
+/*
+ * Get the maximum number of virtqueue elements that can be inserted
+ * into a virtio sound pcm stream
+ *
+ * @st: virtio sound pcm stream
+ */
+static int virtio_snd_pcm_get_nelems(virtio_snd_pcm_stream *st) {
+    return st->buffer_bytes / st->period_bytes
+           + !!(st->buffer_bytes % st->period_bytes);
+}
+
+/*
+ * Get the size in bytes of the buffer that still has to be written.
+ *
+ * @st: virtio sound pcm stream
+ */
+static int virtio_snd_pcm_get_pending_bytes(virtio_snd_pcm_stream *st) {
+    int pending = st->r_pos - st->w_pos;
+    return pending < 0 ? pending + st->buffer_bytes : pending;
+}
+
+/*
+ * Get data from a stream of the virtio sound device.
+ *
+ * @st: VirtIOSound card stream
+ * @offset: Start reading from this offseta in the stream (in bytes)
+ * @buffer: Write to this buffer
+ * @size: The number of bytes to read
+ */
+static void virtio_snd_pcm_get_buf(virtio_snd_pcm_stream *st, uint32_t offset,
+                                      void *buffer, uint32_t size)
+{
+    int nelems = virtio_snd_pcm_get_nelems(st);
+    int i = 0;
+    while (offset > st->period_bytes) {
+        offset -= st->period_bytes;
+        i++;
+        i %= nelems;
+    }
+
+
+    // If the size spans beyond the current virtqueue element, read everything
+    // from the current virtqueue element and move to the next element. Repeat
+    // until we have read the required size.
+    while(size) {
+        int remaining = iov_size(st->elems[i]->out_sg, st->elems[i]->out_num)
+                        - sizeof(virtio_snd_pcm_xfer) - offset;
+        int to_read = MIN(remaining, size), wpos=0;
+        size_t sz;
+        sz = iov_to_buf(st->elems[i]->out_sg, st->elems[i]->out_num,
+                        sizeof(virtio_snd_pcm_xfer) + offset, buffer + wpos,
+                        to_read);
+
+        assert(sz == to_read);
+
+        offset = 0;
+        size -= to_read;
+        wpos += to_read;
+        i++;
+        i %= nelems;
+    }
+}
+
+/*
+ * Handle a buffer after it has been written by AUD_write.
+ * It writes the status for the I/O messages that have been completed and
+ * marks the tx virtqueue elmenets as used. It notifies the device
+ * about I/O completion.
+ *
+ * @st: VirtIOSound card stream
+ * @size: Size that was written by AUD_write
+ *        If size = 0, write for the last element failed
+ */
+static void virtio_snd_pcm_handle_buf_written(virtio_snd_pcm_stream *st,
+                                              uint32_t size)
+{
+    int offset = st->w_pos, i = 0;
+    int nelems = virtio_snd_pcm_get_nelems(st);
+
+    while (offset >= st->period_bytes) {
+        offset -= st->period_bytes;
+        i++;
+        i %= nelems;
+    }
+
+    virtio_snd_pcm_status status;
+    size_t sz;
+    if (!size) {
+        status.status = VIRTIO_SND_S_IO_ERR;
+        status.latency_bytes = 0;
+
+        sz = iov_from_buf(st->elems[i]->in_sg, st->elems[i]->in_num, 0,
+                          &status, sizeof(status));
+        assert(sz == sizeof(virtio_snd_pcm_status));
+
+        int push_size = iov_size(st->elems[i]->out_sg, st->elems[i]->out_num)
+                        + sizeof(virtio_snd_pcm_status);
+
+        virtqueue_push(st->s->tx_vq, st->elems[i], push_size);
+        return;
+    }
+
+    status.status = VIRTIO_SND_S_OK;
+    status.latency_bytes = 0;
+
+    // If the written size spans beyond current element, update the status for
+    // the current element, mark it as used and push it back on the tx
+    // virtqueue. Notify the device about the I/O completion. Repeat until
+    // the required bytes are handled.
+    while (size) {
+        int curr_elem_size = iov_size(st->elems[i]->out_sg, st->elems[i]->out_num)
+                             - sizeof(virtio_snd_pcm_xfer) - offset;
+        if (size >= curr_elem_size) {
+            sz = iov_from_buf(st->elems[i]->in_sg, st->elems[i]->in_num, 0,
+                              &status, sizeof(status));
+            assert(sz == sizeof(virtio_snd_pcm_status));
+
+            int push_size = sizeof(virtio_snd_pcm_xfer) + curr_elem_size
+                            + offset + sizeof(virtio_snd_pcm_status);
+
+            virtqueue_push(st->s->tx_vq, st->elems[i], push_size);
+            virtio_notify(VIRTIO_DEVICE(st->s), st->s->tx_vq);
+            g_free(st->elems[i]);
+            st->elems[i] = NULL;
+            size -= curr_elem_size;
+            virtio_snd_log("remains: %d\n", size);
+            st->w_pos += curr_elem_size;
+            st->w_pos %= st->buffer_bytes + 1;
+            i++;
+            i %= nelems;
+            offset = 0;
+        } else {
+            st->w_pos += size;
+            st->w_pos %= st->buffer_bytes + 1;
+            break;
+        }
+    }
+}
+
+/*
+ * Callback for AUD_open_out.
+ * Reads a buffer from the VirtIOSound card stream and writes it
+ * using AUD_write.
+ *
+ * @opaque: VirtIOSound card stream
+ * @free: Size in bytes that can be written via AUD_write
+ */
+static void virtio_snd_output_cb (void *opaque, int free)
+{
+    int to_play, pending;
+    virtio_snd_pcm_stream *st = opaque;
+
+    pending = virtio_snd_pcm_get_pending_bytes(st);
+    to_play = MIN(free, pending);
+
+    while (to_play) {
+        uint8_t *mixbuf = g_malloc0(to_play);
+        virtio_snd_pcm_get_buf(st, st->w_pos, mixbuf, to_play);
+        int wbytes = AUD_write(st->voice.out, mixbuf, to_play);
+        to_play -= wbytes;
+        virtio_snd_pcm_handle_buf_written(st, wbytes);
+        g_free(mixbuf);
+    }
+}
+
+/*
+ * Prepares a VirtIOSound card stream.
+ * Returns a virtio sound status (VIRTIO_SND_S_*).
+ *
+ * @s: VirtIOSound card
+ * @stream: stream id
+ */
+static uint32_t virtio_snd_pcm_prepare_impl(VirtIOSound *s, uint32_t stream)
+{
+    if (!s->streams || !s->pcm_params || !s->pcm_params[stream]) {
+        virtio_snd_err("Cannot prepare stream %d without params.\n", stream);
+        return VIRTIO_SND_S_BAD_MSG;
+    }
+
+    uint32_t supported_formats = 1 << VIRTIO_SND_PCM_FMT_S8 |
+                                 1 << VIRTIO_SND_PCM_FMT_U8 |
+                                 1 << VIRTIO_SND_PCM_FMT_S16 |
+                                 1 << VIRTIO_SND_PCM_FMT_U16 |
+                                 1 << VIRTIO_SND_PCM_FMT_S32 |
+                                 1 << VIRTIO_SND_PCM_FMT_U32 |
+                                 1 << VIRTIO_SND_PCM_FMT_FLOAT;
+
+    uint32_t supported_rates = 1 << VIRTIO_SND_PCM_RATE_5512 |
+                               1 << VIRTIO_SND_PCM_RATE_8000 |
+                               1 << VIRTIO_SND_PCM_RATE_11025 |
+                               1 << VIRTIO_SND_PCM_RATE_16000 |
+                               1 << VIRTIO_SND_PCM_RATE_22050 |
+                               1 << VIRTIO_SND_PCM_RATE_32000 |
+                               1 << VIRTIO_SND_PCM_RATE_44100 |
+                               1 << VIRTIO_SND_PCM_RATE_48000 |
+                               1 << VIRTIO_SND_PCM_RATE_64000 |
+                               1 << VIRTIO_SND_PCM_RATE_88200 |
+                               1 << VIRTIO_SND_PCM_RATE_96000 |
+                               1 << VIRTIO_SND_PCM_RATE_176399 |
+                               1 << VIRTIO_SND_PCM_RATE_192000 |
+                               1 << VIRTIO_SND_PCM_RATE_384000;
+
+    virtio_snd_pcm_stream *st = (virtio_snd_pcm_stream *)
+                                g_malloc0(sizeof(virtio_snd_pcm_stream));
+    st->hda_fn_nid = VIRTIO_SOUND_HDA_FN_NID_OUT;
+    st->features = 0;
+    st->direction = stream <= s->snd_conf.streams / 2 ?
+                    VIRTIO_SND_D_OUTPUT : VIRTIO_SND_D_INPUT;
+    st->channels_min = 1;
+    st->channels_max = AUDIO_MAX_CHANNELS;
+    st->formats = supported_formats;
+    st->rates = supported_rates;
+    st->s = s;
+
+    st->buffer_bytes = s->pcm_params[stream]->buffer_bytes;
+    st->period_bytes = s->pcm_params[stream]->period_bytes;
+
+    audsettings as;
+    virtio_snd_get_qemu_audsettings(&as, s->pcm_params[stream]);
+
+    if (st->direction == VIRTIO_SND_D_OUTPUT) {
+        st->voice.out = AUD_open_out(&s->card, st->voice.out, "virtio_snd_card",
+                                     st, virtio_snd_output_cb, &as);
+    } else {
+        // st->voice.in = AUD_open_in(&s->card, st->voice.in, "virtio_snd_card", st,
+        //        virtio_snd_input_cb, &as);
+    }
+
+    uint32_t nelems = virtio_snd_pcm_get_nelems(st);
+    st->elems = (VirtQueueElement **)
+                g_malloc0(sizeof(VirtQueueElement *) * nelems);
+    st->tail = -1;
+    st->w_pos = 0;
+    st->r_pos = 0;
+    s->streams[stream] = st;
+
+    return VIRTIO_SND_S_OK;
+}
+
+/*
+ * Handles VIRTIO_SND_R_PCM_PREPARE.
+ * The function writes the response to the virtqueue element.
+ * Returns the used size in bytes.
+ *
+ * @s: VirtIOSound card
+ * @elem: The request element from control queue
+ */
+static uint32_t virtio_snd_handle_pcm_prepare(VirtIOSound *s, VirtQueueElement *elem)
+{
+    virtio_snd_pcm_hdr req;
+    size_t sz;
+
+    sz = iov_to_buf(elem->out_sg, elem->out_num, 0, &req, sizeof(req));
+    assert(sz == sizeof(virtio_snd_pcm_hdr));
+
+    virtio_snd_hdr resp;
+    resp.code = virtio_snd_pcm_prepare_impl(s, req.stream_id);
+    sz = iov_from_buf(elem->in_sg, elem->in_num, 0, &resp, sizeof(resp));
+    assert(sz == sizeof(virtio_snd_hdr));
+    return sz;
+}
+
+/*
+ * Handles VIRTIO_SND_R_PCM_START.
+ * The function writes the response to the virtqueue element.
+ * Returns the used size in bytes.
+ *
+ * @s: VirtIOSound card
+ * @elem: The request element from control queue
+ */
+static uint32_t virtio_snd_handle_pcm_start(VirtIOSound *s, VirtQueueElement *elem)
+{
+    virtio_snd_pcm_hdr req;
+    size_t sz;
+
+    sz = iov_to_buf(elem->out_sg, elem->out_num, 0, &req, sizeof(req));
+    assert(sz == sizeof(virtio_snd_pcm_hdr));
+
+    virtio_snd_hdr resp;
+    resp.code = VIRTIO_SND_S_OK;
+
+    virtio_snd_pcm_stream *st = virtio_snd_pcm_get_stream(s, req.stream_id);
+    AUD_set_active_out(st->voice.out, true);
+
+    sz = iov_from_buf(elem->in_sg, elem->in_num, 0, &resp, sizeof(resp));
+    assert(sz == sizeof(virtio_snd_hdr));
+    return sz;
+}
+
+/*
+ * Handles VIRTIO_SND_R_PCM_STOP.
+ * The function writes the response to the virtqueue element.
+ * Returns the used size in bytes.
+ * TODO: Doesn't handle the stream buffers that are yet to be played.
+ *
+ * @s: VirtIOSound card
+ * @elem: The request element from control queue
+ */
+static uint32_t virtio_snd_handle_pcm_stop(VirtIOSound *s, VirtQueueElement *elem)
+{
+    virtio_snd_pcm_hdr req;
+    size_t sz;
+
+    sz = iov_to_buf(elem->out_sg, elem->out_num, 0, &req, sizeof(req));
+    assert(sz == sizeof(virtio_snd_pcm_hdr));
+
+    virtio_snd_hdr resp;
+    resp.code = VIRTIO_SND_S_OK;
+
+    virtio_snd_pcm_stream *st = virtio_snd_pcm_get_stream(s, req.stream_id);
+    AUD_set_active_out(st->voice.out, false);
+
+    sz = iov_from_buf(elem->in_sg, elem->in_num, 0, &resp, sizeof(resp));
+    assert(sz == sizeof(virtio_snd_hdr));
+    return sz;
+}
+
+/*
+ * Releases the resources allocated to a stream. Sepearated from the handler
+ * so that the code could be reused in the unrealize function.
+ *
+ * TODO: Doesn't handle the stream buffers that are yet to be played.
+ *
+ * @s: VirtIOSound card
+ * @stream: stream id
+ */
+static uint32_t virtio_snd_pcm_release_impl(VirtIOSound *s, uint32_t stream)
+{
+    virtio_snd_pcm_stream *st = virtio_snd_pcm_get_stream(s, stream);
+    if (st) {
+        virtio_snd_err("already released %d\n", stream);
+        return VIRTIO_SND_S_BAD_MSG;
+    }
+
+    if (st->voice.out) {
+        AUD_close_out(&s->card, st->voice.out);
+    } else if (st->voice.in) {
+        AUD_close_in(&s->card, st->voice.in);
+    }
+
+    if (st->elems) {
+        int nelems = virtio_snd_pcm_get_nelems(st);
+        for (int i = 0; i < nelems; i++) {
+            if (st->elems[i]) {
+                g_free(st->elems[i]);
+                st->elems[i] = NULL;
+            }
+        }
+        g_free(st->elems);
+        st->elems = NULL;
+    }
+
+    g_free(s->streams[stream]);
+    s->streams[stream] = NULL;
+    return VIRTIO_SND_S_OK;
+}
+
+/*
+ * Handles VIRTIO_SND_R_PCM_RELEASE.
+ * The function writes the response to the virtqueue element.
+ * Returns the used size in bytes.
+ * TODO: Doesn't handle the stream buffers that are yet to be played.
+ *
+ * @s: VirtIOSound card
+ * @elem: The request element from control queue
+ */
+static uint32_t virtio_snd_handle_pcm_release(VirtIOSound *s, VirtQueueElement *elem)
+{
+    virtio_snd_pcm_hdr req;
+    virtio_snd_hdr resp;
+    size_t sz;
+    sz = iov_from_buf(elem->out_sg, elem->out_num, 0, &req, sizeof(req));
+    assert(sz == sizeof(virtio_snd_pcm_hdr));
+
+    virtio_snd_pcm_release_impl(s, req.stream_id);
+
+    sz = iov_from_buf(elem->in_sg, elem->in_num, 0, &resp, sizeof(resp));
+    assert(sz == sizeof(virtio_snd_hdr));
+    return sz;
+}
+
+/* The control queue handler. Pops an element from the control virtqueue,
+ * checks the header and performs the requested action. Finally marks the
+ * element as used.
+ *
+ * @vdev: VirtIOSound card device
+ * @vq: Control virtqueue
+ */
+static void virtio_snd_handle_ctrl(VirtIODevice *vdev, VirtQueue *vq)
+{
+    VirtIOSound *s = VIRTIO_SOUND(vdev);
+    virtio_snd_hdr ctrl, resp;
+
+    VirtQueueElement *elem = NULL;
+    size_t sz;
+    struct iovec *iov, *iov2;
+    unsigned int iov_cnt;
+
+    for(;;) {
+        elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+        if(!elem) {
+            break;
+        }
+        if (iov_size(elem->in_sg, elem->in_num) < sizeof(resp) ||
+                iov_size(elem->out_sg, elem->out_num) < sizeof(ctrl)) {
+            virtio_snd_err("virtio-snd ctrl missing headers\n");
+            virtqueue_detach_element(vq, elem, 0);
+            g_free(elem);
+            break;
+        }
+
+        iov_cnt = elem->out_num;
+        iov2 = iov = g_memdup(elem->out_sg, sizeof(struct iovec) * elem->out_num);
+        sz = iov_to_buf(iov, iov_cnt, 0, &ctrl, sizeof(ctrl));
+        iov_discard_front(&iov, &iov_cnt, sizeof(ctrl));
+        if (sz != sizeof(ctrl)) {
+            // error
+            virtio_snd_err("virtio snd ctrl could not read header\n");
+            resp.code = VIRTIO_SND_S_BAD_MSG;
+        } else if (ctrl.code == VIRTIO_SND_R_JACK_INFO) {
+            sz = virtio_snd_handle_jack_info(s, elem);
+        } else if (ctrl.code == VIRTIO_SND_R_JACK_REMAP) {
+            sz = virtio_snd_handle_jack_remap(s, elem);
+        } else if (ctrl.code == VIRTIO_SND_R_PCM_INFO) {
+            sz = virtio_snd_handle_pcm_info(s, elem);
+        } else if (ctrl.code == VIRTIO_SND_R_PCM_SET_PARAMS) {
+            sz = virtio_snd_handle_pcm_set_params(s, elem);
+        } else if (ctrl.code == VIRTIO_SND_R_PCM_PREPARE) {
+            sz = virtio_snd_handle_pcm_prepare(s, elem);
+        } else if (ctrl.code == VIRTIO_SND_R_PCM_START) {
+            sz = virtio_snd_handle_pcm_start(s, elem);
+        } else if (ctrl.code == VIRTIO_SND_R_PCM_STOP) {
+            sz = virtio_snd_handle_pcm_stop(s, elem);
+        } else if (ctrl.code == VIRTIO_SND_R_PCM_RELEASE) {
+            sz = virtio_snd_handle_pcm_release(s, elem);
+        } else {
+            // error
+            virtio_snd_err("virtio snd header not recognized: %d\n", ctrl.code);
+            resp.code = VIRTIO_SND_S_BAD_MSG;
+        }
+
+        if (resp.code == VIRTIO_SND_S_BAD_MSG)
+            sz = iov_from_buf(elem->in_sg, elem->in_num, 0, &resp, sizeof(resp));
+
+        virtqueue_push(vq, elem, sz);
+        virtio_notify(vdev, vq);
+        g_free(iov2);
+        g_free(elem);
+    }
+}
+
+/*
+ * Adds a virtqueue element to a VirtIOSound card stream. Makes the buffer
+ * available to the stream for consumption.
+ *
+ * @s: VirtIOSound card
+ * @stream: stream id
+ * @elem: The tx virtqueue element that contains the I/O message
+ */
+static void virtio_snd_pcm_add_buf(VirtIOSound *s, uint32_t stream, VirtQueueElement *elem)
+{
+    virtio_snd_pcm_stream *st = virtio_snd_pcm_get_stream(s, stream);
+    int nelems = virtio_snd_pcm_get_nelems(st);
+    st->tail++;
+    st->tail %= nelems;
+
+    if (st->elems[st->tail]) {
+        return;
+    }
+
+    st->elems[st->tail] = elem;
+    st->r_pos += iov_size(elem->out_sg, elem->out_num) - sizeof(virtio_snd_pcm_xfer);
+    st->r_pos %= st->buffer_bytes + 1;
+}
+
+/*
+ * The tx virtqueue handler. Makes the buffers available to their respective
+ * streams for consumption.
+ *
+ * @vdev: VirtIOSound card
+ * @vq: tx virtqueue
+ */
+static void virtio_snd_handle_tx (VirtIODevice *vdev, VirtQueue *vq)
+{
+    VirtIOSound *s = VIRTIO_SOUND(vdev);
+    VirtQueueElement *elem;
+    size_t sz;
+    virtio_snd_pcm_xfer hdr;
+
+    for (;;) {
+        elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+        if (!elem) {
+            break;
+        }
+        if (iov_size(elem->in_sg, elem->in_num) < sizeof(virtio_snd_pcm_status) ||
+            iov_size(elem->out_sg, elem->out_num) < sizeof(virtio_snd_pcm_xfer)) {
+            virtqueue_detach_element(vq, elem, 0);
+            g_free(elem);
+            break;
+        }
+
+        // get the message hdr object
+        sz = iov_to_buf(elem->out_sg, elem->out_num, 0, &hdr, sizeof(hdr));
+        assert(sz == sizeof(virtio_snd_pcm_xfer));
+
+        virtio_snd_pcm_add_buf(s, hdr.stream_id, elem);
+    }
+}
+
+static void virtio_snd_handle_event (VirtIODevice *vdev, VirtQueue *vq)
+{
+    virtio_snd_log("event queue callback called\n");
+}
+
+static void virtio_snd_handle_rx (VirtIODevice *vdev, VirtQueue *vq)
+{
+    virtio_snd_log("rx queue callback called\n");
+}
+
+/*
+ * Initializes the VirtIOSound card device. Validates the configuration
+ * passed by the command line. Initializes the virtqueues. Allocates resources
+ * for and initializes streams, jacks and chmaps.
+ *
+ * @dev: VirtIOSound card device
+ * @errp: Set if there is an error
+ */
+static void virtio_snd_device_realize(DeviceState *dev, Error **errp)
+{
+    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
+    VirtIOSound *s = VIRTIO_SOUND(dev);
+
+    virtio_init(vdev, "virtio-snd", VIRTIO_ID_SOUND, sizeof(virtio_snd_config));
+
+    // set number of jacks and streams
+    if (s->snd_conf.jacks > 8) {
+        error_setg(errp, "Invalid number of jacks: %d", s->snd_conf.jacks);
+        return;
+    }
+    if (s->snd_conf.streams < 1 || s->snd_conf.streams > 10) {
+        error_setg(errp, "Invalid number of streams: %d", s->snd_conf.streams);
+        return;
+    }
+
+    if (s->snd_conf.chmaps > VIRTIO_SND_CHMAP_MAX_SIZE) {
+        error_setg(errp, "Invalid number of channel maps: %d", s->snd_conf.chmaps);
+        return;
+    }
+
+    //  set up QEMUSoundCard and audiodev
+    AUD_register_card ("virtio_snd_card", &s->card);
+
+    // set default params for all streams
+    virtio_snd_pcm_set_params default_params;
+    default_params.features = 0;
+    default_params.buffer_bytes = 8192;
+    default_params.period_bytes = 4096;
+    default_params.channel = 2;
+    default_params.format = VIRTIO_SND_PCM_FMT_S16;
+    default_params.rate = VIRTIO_SND_PCM_RATE_44100;
+
+    s->ctrl_vq = virtio_add_queue(vdev, 64, virtio_snd_handle_ctrl);
+    s->event_vq = virtio_add_queue(vdev, 64, virtio_snd_handle_event);
+    s->tx_vq = virtio_add_queue(vdev, 64, virtio_snd_handle_tx);
+    s->rx_vq = virtio_add_queue(vdev, 64, virtio_snd_handle_rx);
+
+    s->streams = (virtio_snd_pcm_stream **)g_malloc0(sizeof(virtio_snd_pcm_stream) * s->snd_conf.streams);
+    s->pcm_params = (virtio_snd_pcm_params **)g_malloc0(sizeof(virtio_snd_pcm_params) * s->snd_conf.streams);
+    s->jacks = (virtio_snd_jack **)g_malloc0(sizeof(virtio_snd_jack) * s->snd_conf.jacks);
+
+    uint32_t status;
+    for (int i = 0; i < s->snd_conf.streams; i++) {
+        default_params.hdr.stream_id = i;
+        status = virtio_snd_pcm_set_params_impl(s, &default_params);
+        if (status != VIRTIO_SND_S_OK) {
+            error_setg(errp, "Can't initalize stream params.\n");
+            return;
+        }
+        status = virtio_snd_pcm_prepare_impl(s, i);
+        if (status != VIRTIO_SND_S_OK) {
+            error_setg(errp, "Can't prepare streams.\n");
+            return;
+        }
+    }
+
+    for (int i = 0; i < s->snd_conf.jacks; i++) {
+        // TODO: For now the hda_fn_nid connects the starting streams to these
+        // jacks. This isn't working for now since the directions will be wrong
+        // for a few jacks. Similarly the capabilities are just placeholders.
+        s->jacks[i] = (virtio_snd_jack *)g_malloc0(sizeof(virtio_snd_jack));
+        s->jacks[i]->features = 0;
+        s->jacks[i]->hda_fn_nid = i;
+        s->jacks[i]->hda_reg_defconf = ((AC_JACK_PORT_COMPLEX << AC_DEFCFG_PORT_CONN_SHIFT) |
+                                       (AC_JACK_LINE_OUT     << AC_DEFCFG_DEVICE_SHIFT)    |
+                                       (AC_JACK_CONN_1_8     << AC_DEFCFG_CONN_TYPE_SHIFT) |
+                                       (AC_JACK_COLOR_GREEN  << AC_DEFCFG_COLOR_SHIFT)     |
+                                       0x10);
+        s->jacks[i]->hda_reg_caps = AC_PINCAP_OUT;
+        s->jacks[i]->connected = false;
+    }
+}
+
+/*
+ * Frees the resources allocated to the device and then frees the device
+ * itself.
+ *
+ * @dev: VirtIOSound card device
+ */
+static void virtio_snd_device_unrealize(DeviceState *dev)
+{
+    VirtIOSound *s = VIRTIO_SOUND(dev);
+
+    for (int i = 0; i < s->snd_conf.streams; i++) {
+        virtio_snd_pcm_release_impl(s, i);
+        g_free(s->pcm_params[i]);
+        s->pcm_params[i] = NULL;
+    }
+    g_free(s->streams);
+    s->streams = NULL;
+    g_free(s->pcm_params);
+    s->pcm_params = NULL;
+
+    for (int i = 0; i < s->snd_conf.jacks; i++) {
+        g_free(s->jacks[i]);
+        s->jacks[i] = NULL;
+    }
+    g_free(s->jacks);
+    s->jacks = NULL;
+
+    virtio_delete_queue(s->ctrl_vq);
+}
+
+static void virtio_snd_reset(VirtIODevice *vdev)
+{
+}
+
+static void virtio_snd_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);
+
+    device_class_set_props(dc, virtio_snd_properties);
+    dc->vmsd = &vmstate_virtio_snd;
+    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
+    vdc->realize = virtio_snd_device_realize;
+    vdc->unrealize = virtio_snd_device_unrealize;
+    vdc->get_config = virtio_snd_get_config;
+    vdc->set_config = virtio_snd_set_config;
+    vdc->get_features = virtio_snd_get_features;
+    vdc->reset = virtio_snd_reset;
+    vdc->legacy_features = 0;
+    vdc->vmsd = &vmstate_virtio_snd_device;
+}
+
+
+static const TypeInfo virtio_snd_dev_info = {
+    .name = TYPE_VIRTIO_SOUND,
+    .parent = TYPE_VIRTIO_DEVICE,
+    .instance_size = sizeof(VirtIOSound),
+    .class_init = virtio_snd_class_init,
+};
+
+static void virtio_register_types(void)
+{
+    type_register_static(&virtio_snd_dev_info);
+}
+
+#undef virtio_snd_log
+#undef virtio_snd_warn
+#undef virtio_snd_err
+
+type_init(virtio_register_types)
diff --git a/hw/virtio/meson.build b/hw/virtio/meson.build
index 67dc77e00f..6e74be7d1c 100644
--- a/hw/virtio/meson.build
+++ b/hw/virtio/meson.build
@@ -49,6 +49,7 @@ virtio_pci_ss.add(when: 'CONFIG_VIRTIO_SERIAL', if_true: files('virtio-serial-pc
 virtio_pci_ss.add(when: 'CONFIG_VIRTIO_PMEM', if_true: files('virtio-pmem-pci.c'))
 virtio_pci_ss.add(when: 'CONFIG_VIRTIO_IOMMU', if_true: files('virtio-iommu-pci.c'))
 virtio_pci_ss.add(when: 'CONFIG_VIRTIO_MEM', if_true: files('virtio-mem-pci.c'))
+virtio_pci_ss.add(when: 'CONFIG_VIRTIO_SND', if_true: files('virtio-snd-pci.c'))
 
 virtio_ss.add_all(when: 'CONFIG_VIRTIO_PCI', if_true: virtio_pci_ss)
 
diff --git a/hw/virtio/virtio-snd-pci.c b/hw/virtio/virtio-snd-pci.c
new file mode 100644
index 0000000000..b3039e0f8d
--- /dev/null
+++ b/hw/virtio/virtio-snd-pci.c
@@ -0,0 +1,73 @@
+/*
+ * Virtio sound PCI Bindings
+ */
+
+#include "qemu/osdep.h"
+#include "hw/virtio/virtio-snd.h"
+#include "hw/virtio/virtio-pci.h"
+#include "qapi/error.h"
+#include "qemu/module.h"
+#include "qom/object.h"
+
+typedef struct VirtIOSoundPCI VirtIOSoundPCI;
+
+/*
+ * virtio-snd-pci: This extends VirtioPCIProxy.
+ */
+#define TYPE_VIRTIO_SOUND_PCI "virtio-sound-pci-base"
+DECLARE_INSTANCE_CHECKER(VirtIOSoundPCI, VIRTIO_SOUND_PCI,
+                         TYPE_VIRTIO_SOUND_PCI)
+
+struct VirtIOSoundPCI {
+    VirtIOPCIProxy parent_obj;
+    VirtIOSound vdev;
+};
+
+static Property virtio_sound_properties[] = {
+    DEFINE_PROP_BIT("ioeventfd", VirtIOPCIProxy, flags,
+                    VIRTIO_PCI_FLAG_USE_IOEVENTFD_BIT, true),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void virtio_snd_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
+{
+    // DeviceState *qdev = DEVICE(vpci_dev);
+    VirtIOSoundPCI *dev = VIRTIO_SOUND_PCI(vpci_dev);
+    DeviceState *vdev = DEVICE(&dev->vdev);
+
+    qdev_realize(vdev, BUS(&vpci_dev->bus), errp);
+}
+
+static void virtio_snd_pci_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
+    VirtioPCIClass *vpciklass = VIRTIO_PCI_CLASS(klass);
+
+    k->class_id = PCI_CLASS_MULTIMEDIA_AUDIO;
+    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
+    device_class_set_props(dc, virtio_sound_properties);
+    vpciklass->realize = virtio_snd_pci_realize;
+}
+
+static void virtio_snd_pci_instance_init(Object *obj)
+{
+    VirtIOSoundPCI *dev = VIRTIO_SOUND_PCI(obj);
+    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+                                TYPE_VIRTIO_SOUND);
+}
+
+static const VirtioPCIDeviceTypeInfo virtio_snd_pci_info = {
+    .base_name              = TYPE_VIRTIO_SOUND_PCI,
+    .generic_name           = "virtio-snd-pci",
+    .instance_size = sizeof(VirtIOSoundPCI),
+    .instance_init = virtio_snd_pci_instance_init,
+    .class_init    = virtio_snd_pci_class_init,
+};
+
+static void virtio_snd_pci_register(void)
+{
+    virtio_pci_types_register(&virtio_snd_pci_info);
+}
+
+type_init(virtio_snd_pci_register);
diff --git a/include/hw/virtio/virtio-snd.h b/include/hw/virtio/virtio-snd.h
new file mode 100644
index 0000000000..eb787a35a7
--- /dev/null
+++ b/include/hw/virtio/virtio-snd.h
@@ -0,0 +1,393 @@
+/*
+ * Virtio Sound Device
+ */
+
+#ifndef QEMU_VIRTIO_SOUND_H
+#define QEMU_VIRTIO_SOUND_H
+
+#include "qemu/units.h"
+#include "hw/virtio/virtio.h"
+#include "qemu/queue.h"
+#include "audio/audio.h"
+#include "audio/audio_int.h"
+
+#define VIRTIO_ID_SOUND 25
+
+#define TYPE_VIRTIO_SOUND "virtio-sound-device"
+OBJECT_DECLARE_SIMPLE_TYPE(VirtIOSound, VIRTIO_SOUND)
+
+/* CONFIGURATION SPACE */
+
+typedef struct virtio_snd_config {
+    /* # of jacks available */
+    uint32_t jacks;
+    /* # of streams avalable */
+    uint32_t streams;
+    /* # chmaps available */
+    uint32_t chmaps;
+} virtio_snd_config;
+
+/* COMMON DEFINITIONS */
+
+/* supported sample data directions. */
+enum {
+    VIRTIO_SND_D_OUTPUT = 0,
+    VIRTIO_SND_D_INPUT
+};
+
+enum {
+    /* jack control request types */
+    VIRTIO_SND_R_JACK_INFO=1,
+    VIRTIO_SND_R_JACK_REMAP,
+
+    /* PCM control request types */
+    VIRTIO_SND_R_PCM_INFO = 0x0100,
+    VIRTIO_SND_R_PCM_SET_PARAMS,
+    VIRTIO_SND_R_PCM_PREPARE,
+    VIRTIO_SND_R_PCM_RELEASE,
+    VIRTIO_SND_R_PCM_START,
+    VIRTIO_SND_R_PCM_STOP,
+
+    /* channel map control request type */
+    VIRTIO_SND_R_CHMAP_INFO=0x200,
+
+    /* jack event types */
+    VIRTIO_SND_EVT_JACK_CONNECTED = 0x1000,
+    VIRTIO_SND_EVT_JACK_DISCONNECTED,
+
+    /* PCM event types */
+    VIRTIO_SND_EVT_PCM_PERIOD_ELAPSED = 0x1100,
+    VIRTIO_SND_EVT_PCM_XRUN,
+
+    /* common status codes */
+    VIRTIO_SND_S_OK = 0x8000,
+    VIRTIO_SND_S_BAD_MSG,
+    VIRTIO_SND_S_NOT_SUPP,
+    VIRTIO_SND_S_IO_ERR
+};
+
+/* common header for request/response*/
+typedef struct virtio_snd_hdr {
+    uint32_t code;
+} virtio_snd_hdr;
+
+/* event notification */
+typedef struct virtio_snd_event {
+    /* VIRTIO_SND_EVT_* */
+    virtio_snd_hdr hdr;
+    /* Optional event data */
+    uint32_t data;
+} virtio_snd_event;
+
+/* common control request to query an item information */
+typedef struct virtio_snd_query_info {
+    /* VIRTIO_SND_R_*_INFO */
+    struct virtio_snd_hdr hdr;
+    /* item start identifier */
+    uint32_t start_id;
+    /* # of items to query */
+    uint32_t count;
+    /* size of a single item information in bytes */
+    uint32_t size;
+} virtio_snd_query_info;
+
+/* common item information header */
+typedef struct virtio_snd_info {
+    /* functional group node id (HDA Spec 7.1.2) */
+    uint32_t hda_fn_nid;
+} virtio_snd_info;
+
+/* JACK CONTROL MESSAGES */
+
+typedef struct virtio_snd_jack_hdr {
+    /* VIRTIO_SND_R_JACK_* */
+    virtio_snd_hdr hdr;
+    /* 0 to (virtio_snd_config.jacks - 1) */
+    uint32_t jack_id;
+} virtio_snd_jack_hdr;
+
+/* Supported jack features */
+enum {
+    VIRTIO_SND_F_JACK_REMAP = 0
+};
+
+/* jack information structure */
+typedef struct virtio_snd_jack_info {
+    /* common header */
+    virtio_snd_info hdr;
+    /* 1 << VIRTIO_SND_JACK_F_* */
+    uint32_t features;
+    /* pin default configuration from HDA spec */
+    uint32_t hda_reg_defconf;
+    /* pin capabilities from HDA spec */
+    uint32_t hda_reg_caps;
+    /* connection status (0: disconnected, 1: connected) */
+    uint8_t connected;
+
+    uint8_t padding[7];
+} virtio_snd_jack_info;
+
+/* jack remapping control request */
+typedef struct virtio_snd_jack_remap {
+    /* .code = VIRTIO_SND_R_JACK_REMAP */
+    virtio_snd_jack_hdr hdr;
+    /* selected association number */
+    uint32_t association;
+    /* selected sequence number */
+    uint32_t sequence;
+} virtio_snd_jack_remap;
+
+/* PCM CONTROL MESSAGES */
+
+typedef struct virtio_snd_pcm_hdr {
+    /* .code = VIRTIO_SND_R_PCM_* */
+    virtio_snd_hdr hdr;
+    /* 0 to (virtio_snd_config.streams - 1) */
+    uint32_t stream_id;
+} virtio_snd_pcm_hdr;
+
+
+/* Supported PCM stream features */
+enum {
+    VIRTIO_SND_PCM_F_SHMEM_HOST = 0,
+    VIRTIO_SND_PCM_F_SHMEM_GUEST,
+    VIRTIO_SND_PCM_F_MSG_POLLING,
+    VIRTIO_SND_PCM_F_EVT_SHMEM_PERIODS,
+    VIRTIO_SNDPCM_F_EVT_XRUNS
+};
+
+/* PCM stream flags */
+enum {
+    VIRTIO_SND_PCM_FL_CHMAP = 0
+};
+
+/* Supported sample formats */
+enum {
+    /* analog formats (width / physical width) */
+    VIRTIO_SND_PCM_FMT_IMA_ADPCM = 0,   /*  4 /  4 bits */
+    VIRTIO_SND_PCM_FMT_MU_LAW,          /*  8 /  8 bits */
+    VIRTIO_SND_PCM_FMT_A_LAW,           /*  8 /  8 bits */
+    VIRTIO_SND_PCM_FMT_S8,              /*  8 /  8 bits */
+    VIRTIO_SND_PCM_FMT_U8,              /*  8 /  8 bits */
+    VIRTIO_SND_PCM_FMT_S16,             /* 16 / 16 bits */
+    VIRTIO_SND_PCM_FMT_U16,             /* 16 / 16 bits */
+    VIRTIO_SND_PCM_FMT_S18_3,           /* 18 / 24 bits */
+    VIRTIO_SND_PCM_FMT_U18_3,           /* 18 / 24 bits */
+    VIRTIO_SND_PCM_FMT_S20_3,           /* 20 / 24 bits */
+    VIRTIO_SND_PCM_FMT_U20_3,           /* 20 / 24 bits */
+    VIRTIO_SND_PCM_FMT_S24_3,           /* 24 / 24 bits */
+    VIRTIO_SND_PCM_FMT_U24_3,           /* 24 / 24 bits */
+    VIRTIO_SND_PCM_FMT_S20,             /* 20 / 32 bits */
+    VIRTIO_SND_PCM_FMT_U20,             /* 20 / 32 bits */
+    VIRTIO_SND_PCM_FMT_S24,             /* 24 / 32 bits */
+    VIRTIO_SND_PCM_FMT_U24,             /* 24 / 32 bits */
+    VIRTIO_SND_PCM_FMT_S32,             /* 32 / 32 bits */
+    VIRTIO_SND_PCM_FMT_U32,             /* 32 / 32 bits */
+    VIRTIO_SND_PCM_FMT_FLOAT,           /* 32 / 32 bits */
+    VIRTIO_SND_PCM_FMT_FLOAT64,         /* 64 / 64 bits */
+    /* digital formats (width / physical width) */
+    VIRTIO_SND_PCM_FMT_DSD_U8,          /*  8 /  8 bits */
+    VIRTIO_SND_PCM_FMT_DSD_U16,         /* 16 / 16 bits */
+    VIRTIO_SND_PCM_FMT_DSD_U32,         /* 32 / 32 bits */
+    VIRTIO_SND_PCM_FMT_IEC958_SUBFRAME  /* 32 / 32 bits */
+};
+
+/* Supported PCM frame rates */
+enum {
+    VIRTIO_SND_PCM_RATE_5512 = 0,
+    VIRTIO_SND_PCM_RATE_8000,
+    VIRTIO_SND_PCM_RATE_11025,
+    VIRTIO_SND_PCM_RATE_16000,
+    VIRTIO_SND_PCM_RATE_22050,
+    VIRTIO_SND_PCM_RATE_32000,
+    VIRTIO_SND_PCM_RATE_44100,
+    VIRTIO_SND_PCM_RATE_48000,
+    VIRTIO_SND_PCM_RATE_64000,
+    VIRTIO_SND_PCM_RATE_88200,
+    VIRTIO_SND_PCM_RATE_96000,
+    VIRTIO_SND_PCM_RATE_176399,
+    VIRTIO_SND_PCM_RATE_192000,
+    VIRTIO_SND_PCM_RATE_384000
+};
+
+/* PCM stream info structure */
+typedef struct virtio_snd_pcm_info {
+    /* common header */
+    virtio_snd_info hdr;
+    /* supported features bitmap (1 << VIRTIO_SND_PCM_F_*) */
+    uint32_t features;
+    /* supported sample formats bitmap (1 << VIRTIO_SND_PCM_FMT_*) */
+    uint64_t formats;
+    /* supported sample rates bitmap (1 << VIRTIO_SND_PCM_RATE_*) */
+    uint64_t rates;
+    /* direction of the stream (VIRTIO_SND_D_*) */
+    uint8_t direction;
+    /* min # of supported channels */
+    uint8_t channels_min;
+    /* max # of supported channels */
+    uint8_t channels_max;
+
+    uint8_t padding[5];
+} virtio_snd_pcm_info;
+
+/* set PCM stream params */
+typedef struct virtio_snd_pcm_set_params {
+    virtio_snd_pcm_hdr hdr;
+    /* size of hardware buffer in bytes */
+    uint32_t buffer_bytes;
+    /* size of hardware period in bytes */
+    uint32_t period_bytes;
+    /* selected feature bitmap */
+    uint32_t features;
+    /* number of channels */
+    uint8_t channel;
+    /* VIRTIO_SND_PCM_FMT_* */
+    uint8_t format;
+    /* VIRTIO_SND_PCM_RATE_* */
+    uint8_t rate;
+
+    uint8_t padding;
+} virtio_snd_pcm_set_params;
+
+/* PCM I/O MESSAGES */
+
+/* I/O request header */
+typedef struct virtio_snd_pcm_xfer {
+    /* 0 to (virtio_snd_config.stream - 1 */
+    uint32_t stream_id;
+} virtio_snd_pcm_xfer;
+
+/* I/O request status */
+typedef struct virtio_snd_pcm_status {
+    /* VIRTIO_SND_S_* */
+    uint32_t status;
+    /* current device latency */
+    uint32_t latency_bytes;
+} virtio_snd_pcm_status;
+
+/* CHANNEL MAP CONTROL MESSAGES */
+
+typedef struct virtio_snd_chmap_hdr {
+    /* .code = VIRTIO_SND_R_CHMAP_* */
+    virtio_snd_hdr hdr;
+    /* 0 to (virtio_snd_config.chmaps - 1) */
+    uint32_t chmap_id;
+} virtio_snd_chmap_hdr;
+
+/* standard channel position definition */
+enum {
+    VIRTIO_SND_CHMAP_NONE = 0,  /* undefined */
+    VIRTIO_SND_CHMAP_NA,        /* silent */
+    VIRTIO_SND_CHMAP_MONO,      /* mono stream */
+    VIRTIO_SND_CHMAP_FL,        /* front left */
+    VIRTIO_SND_CHMAP_FR,        /* front right */
+    VIRTIO_SND_CHMAP_RL,        /* rear left */
+    VIRTIO_SND_CHMAP_RR,        /* rear right */
+    VIRTIO_SND_CHMAP_FC,        /* front center */
+    VIRTIO_SND_CHMAP_LFE,       /* low frequency (LFE) */
+    VIRTIO_SND_CHMAP_SL,        /* side left */
+    VIRTIO_SND_CHMAP_SR,        /* side right */
+    VIRTIO_SND_CHMAP_RC,        /* rear center */
+    VIRTIO_SND_CHMAP_FLC,       /* front left center */
+    VIRTIO_SND_CHMAP_FRC,       /* front right center */
+    VIRTIO_SND_CHMAP_RLC,       /* rear left center */
+    VIRTIO_SND_CHMAP_RRC,       /* rear right center */
+    VIRTIO_SND_CHMAP_FLW,       /* front left wide */
+    VIRTIO_SND_CHMAP_FRW,       /* front right wide */
+    VIRTIO_SND_CHMAP_FLH,       /* front left high */
+    VIRTIO_SND_CHMAP_FCH,       /* front center high */
+    VIRTIO_SND_CHMAP_FRH,       /* front right high */
+    VIRTIO_SND_CHMAP_TC,        /* top center */
+    VIRTIO_SND_CHMAP_TFL,       /* top front left */
+    VIRTIO_SND_CHMAP_TFR,       /* top front right */
+    VIRTIO_SND_CHMAP_TFC,       /* top front center */
+    VIRTIO_SND_CHMAP_TRL,       /* top rear left */
+    VIRTIO_SND_CHMAP_TRR,       /* top rear right */
+    VIRTIO_SND_CHMAP_TRC,       /* top rear center */
+    VIRTIO_SND_CHMAP_TFLC,      /* top front left center */
+    VIRTIO_SND_CHMAP_TFRC,      /* top front right center */
+    VIRTIO_SND_CHMAP_TSL,       /* top side left */
+    VIRTIO_SND_CHMAP_TSR,       /* top side right */
+    VIRTIO_SND_CHMAP_LLFE,      /* left LFE */
+    VIRTIO_SND_CHMAP_RLFE,      /* right LFE */
+    VIRTIO_SND_CHMAP_BC,        /* bottom center */
+    VIRTIO_SND_CHMAP_BLC,       /* bottom left center */
+    VIRTIO_SND_CHMAP_BRC        /* bottom right center */
+};
+
+/* maximum possible number of channels */
+#define VIRTIO_SND_CHMAP_MAX_SIZE   18
+
+typedef struct virtio_snd_chmap_info {
+    /* common header */
+    virtio_snd_info hdr;
+    /* direction */
+    uint8_t direction;
+    /* # of valid channel position values */
+    uint8_t channels;
+    /* channel position values (VIRTIO_SND_CHMAP_*) */
+    uint8_t positions[VIRTIO_SND_CHMAP_MAX_SIZE];
+} virtio_snd_chmap_info;
+
+/* VIRTIO SOUND DEVICE */
+
+/* Jacks */
+typedef struct virtio_snd_jack {
+    uint32_t features; /* 1 << VIRTIO_SND_JACK_F_XXX */
+    uint32_t hda_fn_nid;
+    uint32_t hda_reg_defconf;
+    uint32_t hda_reg_caps;
+    uint8_t connected;
+} virtio_snd_jack;
+
+/* Streams */
+typedef struct virtio_snd_pcm_stream {
+    uint32_t hda_fn_nid;
+    uint32_t buffer_bytes;
+    uint32_t period_bytes;
+    uint32_t features; /* 1 << VIRTIO_SND_PCM_F_XXX */
+    uint32_t flags; /* 1 << VIRTIO_SND_PCM_FL_XXX */
+    uint32_t direction;
+    uint8_t channels_min;
+    uint8_t channels_max;
+    uint64_t formats; /* 1 << VIRTIO_SND_PCM_FMT_XXX */
+    uint64_t rates; /* 1 << VIRTIO_SND_PCM_RATE_XXX */
+    int tail, r_pos, w_pos;
+    VirtQueueElement **elems;
+    VirtIOSound *s;
+    union {
+        SWVoiceIn *in;
+        SWVoiceOut *out;
+    } voice;
+} virtio_snd_pcm_stream;
+
+/* Stream params */
+typedef struct virtio_snd_pcm_params {
+    uint32_t features;
+    uint32_t buffer_bytes;          /* size of hardware buffer in bytes */
+    uint32_t period_bytes;          /* size of hardware period in bytes */
+    uint8_t channel;
+    uint8_t format;
+    uint8_t rate;
+} virtio_snd_pcm_params;
+
+/* Sound device */
+struct VirtIOSound {
+    /* Parent VirtIODevice object */
+    VirtIODevice parent_obj;
+    virtio_snd_config snd_conf;
+
+    VirtQueue *ctrl_vq;
+    VirtQueue *event_vq;
+    VirtQueue *tx_vq;
+    VirtQueue *rx_vq;
+
+    QEMUSoundCard card;
+    size_t config_size;
+
+    virtio_snd_pcm_params **pcm_params;
+    virtio_snd_pcm_stream **streams;
+    virtio_snd_jack **jacks;
+};
+
+#endif
